<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Transit Graph Analytics</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 20px; background: #f4f7f6; color: #333; }
  h1 { text-align: center; color: #005a9c; }
  #controls { text-align: center; margin-bottom: 20px; }
  select, input.text-input, button { font-size: 1.1em; padding: 8px 12px; border-radius: 5px; border: 1px solid #ccc; margin: 5px; width: 50%; max-width: 500px; }
  #results { margin-top: 20px; }
  #network { width: 100%; height: 400px; border: 1px solid #ccc; background: #fff; margin-top: 30px; }
  .card { background: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
  .card h3 { margin-top: 0; color: #005a9c; }
  .suggestions { position: absolute; background: #fff; border: 1px solid #ccc; max-height: 200px; overflow-y: auto; width: 50%; max-width: 500px; z-index: 1000; display: none; }
  .suggestion-item { padding: 8px 12px; cursor: pointer; }
  .suggestion-item:hover { background: #f0f6ff; }
  .autocomplete-wrapper { position: relative; display: inline-block; width: 50%; max-width: 500px; }
  .hidden { display: none !important; }
</style>
</head>
<body>
<h1>Transit Graph Analytics</h1>

<div id="controls">
  <div class="autocomplete-wrapper" id="origin-wrapper">
    <input id="origin-input" class="text-input" placeholder="Origin stop..." autocomplete="off"/>
    <div id="origin-suggestions" class="suggestions"></div>
  </div>
  <div class="autocomplete-wrapper" id="destination-wrapper">
    <input id="destination-input" class="text-input" placeholder="Destination stop..." autocomplete="off"/>
    <div id="destination-suggestions" class="suggestions"></div>
  </div>
  <div id="hops-wrapper">
    <input id="hops-input" type="number" min="1" value="2" style="width:100px;" placeholder="Hops" />
  </div>
  <div>
    <select id="query-type">
      <option value="shortest_path">Shortest Path</option>
      <option value="reachable_stops">Reachable Stops (N hops)</option>
      <option value="centrality">Top Central Stops</option>
    </select>
    <button id="run-query">Run Query</button>
  </div>
</div>

<div id="results"></div>
<h2 style="text-align:center; color:#005a9c;">Transit Graph Visualization</h2>
<div id="network"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const originInput = document.getElementById("origin-input");
  const destInput = document.getElementById("destination-input");
  const originSuggestions = document.getElementById("origin-suggestions");
  const destSuggestions = document.getElementById("destination-suggestions");
  const queryType = document.getElementById("query-type");
  const hopsInput = document.getElementById("hops-input");
  const runBtn = document.getElementById("run-query");
  const resultsDiv = document.getElementById("results");
  const networkDiv = document.getElementById("network");

  const originWrapper = document.getElementById("origin-wrapper");
  const destinationWrapper = document.getElementById("destination-wrapper");
  const hopsWrapper = document.getElementById("hops-wrapper");

  let allStops = [], originId = null, destinationId = null;
  const width = networkDiv.clientWidth;
  const height = 400;

  fetch("http://127.0.0.1:5000/get_stops")
      .then(res => res.json())
      .then(data => { allStops = data || []; })
      .catch(e => console.error(e));

  function renderSuggestions(inputEl, suggestionsEl, callback) {
      const term = inputEl.value.toLowerCase();
      if(!term) { suggestionsEl.style.display='none'; suggestionsEl.innerHTML=''; return; }
      const matches = allStops.filter(s => s.stop_name.toLowerCase().includes(term) || String(s.stop_id).includes(term)).slice(0,20);
      suggestionsEl.innerHTML = matches.map(s=>`<div class="suggestion-item" data-id="${s.stop_id}" data-name="${s.stop_name}">${s.stop_name}</div>`).join('');
      suggestionsEl.style.display = matches.length ? 'block' : 'none';
      suggestionsEl.querySelectorAll('.suggestion-item').forEach(item=>{ item.addEventListener('click', ()=>callback(item.dataset.id, item.dataset.name)); });
  }

  function selectOrigin(id,name){ originId=id; originInput.value=name; originSuggestions.style.display='none'; }
  function selectDest(id,name){ destinationId=id; destInput.value=name; destSuggestions.style.display='none'; }

  originInput.addEventListener('input', ()=>renderSuggestions(originInput, originSuggestions, selectOrigin));
  destInput.addEventListener('input', ()=>renderSuggestions(destInput, destSuggestions, selectDest));

  function updateInputVisibility() {
      const q = queryType.value;
      if(q === "shortest_path") {
          originWrapper.classList.remove("hidden");
          destinationWrapper.classList.remove("hidden");
          hopsWrapper.classList.add("hidden");
      } else if(q === "reachable_stops") {
          originWrapper.classList.remove("hidden");
          destinationWrapper.classList.add("hidden");
          hopsWrapper.classList.remove("hidden");
      } else if(q === "centrality") {
          originWrapper.classList.add("hidden");
          destinationWrapper.classList.add("hidden");
          hopsWrapper.classList.add("hidden");
      }
  }

  queryType.addEventListener("change", updateInputVisibility);
  updateInputVisibility();

  runBtn.addEventListener('click', async () => {
      resultsDiv.innerHTML = "Running query...";
      let url = "", params = {};

      if(queryType.value==="shortest_path"){
          if(!originId || !destinationId){ resultsDiv.innerHTML="Select origin and destination."; return; }
          url = "http://127.0.0.1:5000/shortest_path";
          params = { origin_stop_id: originId, destination_stop_id: destinationId };
      } else if(queryType.value==="reachable_stops"){
          if(!originId){ resultsDiv.innerHTML="Select origin stop."; return; }
          url = "http://127.0.0.1:5000/reachable_stops";
          params = { origin_stop_id: originId, hops: hopsInput.value || 2 };
      } else if(queryType.value==="centrality"){
          url = "http://127.0.0.1:5000/centrality";
          params = {};
      }

      const queryUrl = new URL(url);
      Object.keys(params).forEach(k=>queryUrl.searchParams.append(k,params[k]));

      try{
          const res = await fetch(queryUrl.toString());
          const data = await res.json();
          resultsDiv.innerHTML='';
          if(!data || data.length===0){ resultsDiv.innerHTML="No results found."; return; }

          let pathNames = [];
          if(queryType.value==="shortest_path"){
              resultsDiv.innerHTML = `<div class="card"><h3>Shortest Path (Length: ${data[0].distance})</h3><p>${data[0].path.join(" â†’ ")}</p></div>`;
              pathNames = data[0].path;
          } else if(queryType.value==="reachable_stops"){
              resultsDiv.innerHTML = `<div class="card"><h3>Stops reachable within ${hopsInput.value} hops:</h3><ul>${data.map(d=>`<li>${d}</li>`).join('')}</ul></div>`;
              pathNames = [originInput.value, ...data];
          } else if(queryType.value==="centrality"){
              resultsDiv.innerHTML = `<div class="card"><h3>Top Central Stops</h3><ol>${data.map(d=>`<li>${d.stop_name} (Score: ${d.score})</li>`).join('')}</ol></div>`;
              pathNames = data.map(d=>d.stop_name);
          }

          drawPathGraph(pathNames);

      } catch(e){ console.error(e); resultsDiv.innerHTML="Error running query."; }
  });

  function drawPathGraph(path) {
      d3.select("#network").selectAll("*").remove();
      const nodes = path.map((name,i)=>({id:i,name}));
      const links = path.slice(0,-1).map((_,i)=>({source:i,target:i+1}));
      const svg = d3.select("#network").append("svg").attr("width", width).attr("height", height);
      const g = svg.append("g");

      const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d=>d.id).distance(80))
          .force("charge", d3.forceManyBody().strength(-200))
          .force("center", d3.forceCenter(width/2,height/2));

      const linkElements = g.append("g").selectAll("line")
          .data(links)
          .join("line")
          .attr("stroke","#999")
          .attr("stroke-width",2);

      const nodeElements = g.append("g").selectAll("circle")
          .data(nodes)
          .join("circle")
          .attr("r",8)
          .attr("fill","#ff6600")
          .call(d3.drag()
              .on("start",(event,d)=>{ if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
              .on("drag",(event,d)=>{ d.fx=event.x; d.fy=event.y; })
              .on("end",(event,d)=>{ if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; })
          );

      const labelElements = g.append("g").selectAll("text")
          .data(nodes)
          .join("text")
          .text(d=>d.name)
          .attr("font-size","10px")
          .attr("dx",12)
          .attr("dy",4);

      simulation.on("tick", ()=> {
          linkElements
              .attr("x1",d=>d.source.x)
              .attr("y1",d=>d.source.y)
              .attr("x2",d=>d.target.x)
              .attr("y2",d=>d.target.y);
          nodeElements
              .attr("cx",d=>d.x)
              .attr("cy",d=>d.y);
          labelElements
              .attr("x",d=>d.x)
              .attr("y",d=>d.y);
      });

      const zoom = d3.zoom()
          .scaleExtent([0.1, 10])
          .on("zoom", (event) => { g.attr("transform", event.transform); });
      svg.call(zoom);

      simulation.on("end", () => {
          const bounds = g.node().getBBox();
          const scale = 0.9 / Math.max(bounds.width / width, bounds.height / height);
          const translate = [
              width / 2 - (bounds.x + bounds.width / 2) * scale,
              height / 2 - (bounds.y + bounds.height / 2) * scale
          ];
          svg.transition().duration(750).call(
              zoom.transform,
              d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
          );
      });
  }
});
</script>
</body>
</html>